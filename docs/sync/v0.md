# Sync Protocol v0 (Draft)

This document describes a minimal, transport-agnostic synchronization protocol for TreeCRDT operation logs.

## Goals
- Allow two peers who have been offline to efficiently exchange missing operations and converge.
- Work over any transport (libp2p, WebSocket, HTTP, etc).
- Be language/runtime neutral (TypeScript today; Rust later).
- Support filtered sync (query-based sync) for partial synchronization.
- Support multiple concurrent filter queries in a single sync session.

## Non-goals (v0)
- Encryption / E2EE / group key management.
- ACL rules, signature verification, or identity management beyond stable `replicaId`s.
- Snapshots, compression, or advanced anti-entropy.

## Background

TreeCRDT operations are uniquely identified by `(replicaId, counter)` (a per-replica monotonic counter).

Traditional sync uses **version vectors**: for each replica, track the maximum counter seen.
However, version vectors assume **contiguous knowledge** — if you have counter N, you have 1..N.

**Filtered sync breaks this assumption.** When syncing only a subtree or predicate-matching ops,
knowledge becomes **sparse** (e.g., you have R#2, R#5, R#8 but not R#1, R#3, R#4...).

This protocol uses **Rateless IBLT (Invertible Bloom Lookup Tables)** for set reconciliation,
which works correctly for both contiguous and sparse knowledge without false positives.

## Terms
- `docId`: document identifier / namespace used to avoid mixing ops from different documents.
- `replicaId`: stable identifier for an author/device/replica. Treated as opaque bytes.
- `counter`: monotonically increasing per `replicaId`.
- `opId`: `(replicaId, counter)` — unique operation identifier.
- `lamport`: logical timestamp carried by each op for ordering and clock observation.
- `filter`: predicate defining which operations to sync (null = all ops).
- `nodeId`: unique identifier for a node in the tree.
- `IBLT`: Invertible Bloom Lookup Table — data structure for set reconciliation.
- `rateless IBLT`: IBLT variant that streams cells until receiver can decode.

## Protocol Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        Sync Session                              │
├─────────────────────────────────────────────────────────────────┤
│  1. Hello: Exchange capabilities, clock, propose filters         │
│                                                                  │
│  2. IBLT Reconciliation (per filter, can run in parallel):      │
│     A → B: Stream IBLT cells for ops matching filter             │
│     B: Subtract own matching ops, attempt decode                 │
│     B → A: "decoded" or "need-more"                             │
│     (repeat until decoded or limit reached)                      │
│                                                                  │
│  3. Op Transfer:                                                 │
│     B → A: Ops that A is missing (from IBLT decode)             │
│     A → B: Ops that B is missing (bidirectional)                │
│                                                                  │
│  4. (Optional) Subscribe: Ongoing filtered updates               │
└─────────────────────────────────────────────────────────────────┘
```

## Filters (Query-Based Sync)

A `filter` defines which operations are relevant to a sync session.
**filter: null** means sync all operations (equivalent to traditional full sync).

### Filter Types

```json
{
  "type": "subtree",
  "root": "nodeId",
  "depth": null,
  "includeAncestors": true
}
```

```json
{
  "type": "nodes",
  "nodeIds": ["node-1", "node-2", "node-3"]
}
```

```json
{
  "type": "predicate",
  "field": "content",
  "op": "contains",
  "value": "hello"
}
```

```json
{
  "type": "lamport_range",
  "minLamport": 100,
  "maxLamport": 500
}
```

```json
{
  "type": "compound",
  "op": "and",
  "filters": [ /* nested filters */ ]
}
```

### Supported Filter Types (v0)

| Type | Description | Server-Side Support Required |
|------|-------------|------------------------------|
| `subtree` | Ops affecting a subtree | Index on parent/node |
| `nodes` | Ops affecting specific node IDs | Index on node ID |
| `lamport_range` | Ops within lamport range | Index on lamport |
| `predicate` | Content-based filtering | Full scan or content index |
| `compound` | Logical AND/OR of filters | Depends on sub-filters |

Servers MAY reject filters they cannot efficiently evaluate with error code `filter_not_supported`.

### Operation Relevance

An operation **matches** a filter based on the filter type:

**Subtree filter**: Op matches if:
1. `op.node` is within the subtree (descendant of root, within depth).
2. `op.parent` or `op.newParent` is within the subtree.
3. `includeAncestors: true` AND `op.node` is an ancestor of the subtree root.

**Nodes filter**: Op matches if `op.node` is in the `nodeIds` set.

**Predicate filter**: Op matches if the predicate evaluates to true against op/node data.

**Lamport range filter**: Op matches if `minLamport <= op.lamport <= maxLamport`.

**Compound filter**: Op matches based on AND/OR logic of sub-filters.

## Rateless IBLT Reconciliation

This protocol uses **Rateless IBLT** for set reconciliation. Unlike bloom filters, IBLT provides
**exact reconciliation with no false positives**.

### How IBLT Works

An IBLT is a data structure that can:
1. Insert items (opIds)
2. Be subtracted from another IBLT
3. Decode to extract the symmetric difference

**Rateless** means the sender streams IBLT cells until the receiver can decode — no need to
pre-negotiate sizes or know the difference size upfront.

### One-Way IBLT Sync

```
A wants to sync with B (A is the initiator):

1. A builds IBLT of opIds matching filter
2. A → B: Stream IBLT cells
3. B subtracts own matching opIds from received IBLT
4. B attempts decode:
   - Success: B knows exactly which ops A is missing
   - Failure: B → A: "need-more"
5. Repeat 2-4 until decoded
6. B → A: Send missing ops
```

### Bidirectional Sync

For bidirectional sync, run the protocol in both directions (can be parallelized):
- A sends IBLT to B → B learns what A is missing → B sends ops to A
- B sends IBLT to A → A learns what B is missing → A sends ops to B

### Why IBLT Over Bloom Filters

| Aspect | Bloom Filter | Rateless IBLT |
|--------|--------------|---------------|
| False positives | ~1% (might skip needed ops) | **None** |
| Communication | O(n) — size of known set | O(d) — size of difference |
| Bidirectional | Requires two exchanges | Single structure encodes both directions |
| Small differences | Wasteful | Efficient |
| Large differences | Efficient | Still works, more cells needed |

### IBLT Cell Format

Each IBLT cell contains:
```json
{
  "count": 1,           // Number of items XORed into this cell
  "keySum": "base64",   // XOR of all opId hashes in this cell  
  "valueSum": "base64"  // XOR of all opId values in this cell
}
```

Cells are streamed in batches. The receiver attempts decode after each batch.

### Multiple Filters (Parallel Reconciliation)

A sync session can reconcile multiple filters simultaneously:

```json
{
  "type": "hello",
  "v": 0,
  "docId": "my-doc",
  "filters": [
    { "id": "f1", "filter": { "type": "subtree", "root": "proj-A" } },
    { "id": "f2", "filter": { "type": "subtree", "root": "proj-B" } },
    { "id": "f3", "filter": { "type": "predicate", "field": "content", "op": "contains", "value": "urgent" } }
  ],
  "maxLamport": 42
}
```

Each filter gets its own IBLT stream, identified by `filterId`. Benefits:
- Filters with different set sizes get appropriate cell counts
- Receiver can prioritize certain filters
- Partial failures don't block everything
- Better parallelization

## Encoding

This spec defines message *fields* and *semantics*. The wire encoding is transport-specific.

- Examples in this doc use JSON-like objects for readability.
- Real implementations SHOULD use a canonical binary encoding (CBOR / protobuf) so that:
  - message sizes are smaller, and
  - it is easy to define canonical "bytes-to-sign" later for authenticated sync.

## Message types

All messages MUST include:
- `type`: discriminant
- `v`: protocol version (`0`)
- `docId`

### 1) `Hello`
Initiates a sync session, proposes filters, exchanges clock state.

Example (single filter):
```json
{
  "type": "hello",
  "v": 0,
  "docId": "my-doc",
  "filters": [
    { "id": "f1", "filter": { "type": "subtree", "root": "proj-A", "includeAncestors": true } }
  ],
  "maxLamport": 42
}
```

Example (multiple filters - parallel sync):
```json
{
  "type": "hello",
  "v": 0,
  "docId": "my-doc",
  "filters": [
    { "id": "f1", "filter": { "type": "subtree", "root": "proj-A" } },
    { "id": "f2", "filter": { "type": "subtree", "root": "proj-B" } },
    { "id": "f3", "filter": { "type": "predicate", "field": "content", "op": "contains", "value": "urgent" } }
  ],
  "maxLamport": 42
}
```

Example (full sync - all ops):
```json
{
  "type": "hello",
  "v": 0,
  "docId": "my-doc",
  "filters": [
    { "id": "all", "filter": null }
  ],
  "maxLamport": 42
}
```

Fields:
- `filters`: Array of `{id, filter}` pairs. Each filter gets its own IBLT reconciliation stream.
- `maxLamport`: Highest lamport timestamp seen (for clock observation).

### 2) `HelloAck`
Acknowledges hello, confirms which filters are accepted.

```json
{
  "type": "hello_ack",
  "v": 0,
  "docId": "my-doc",
  "acceptedFilters": ["f1", "f2"],
  "rejectedFilters": [
    { "id": "f3", "reason": "filter_not_supported", "message": "predicate filters require content index" }
  ],
  "maxLamport": 50
}
```

### 3) `IBLTCells`
Streams IBLT cells for a specific filter. Sender continues until receiver decodes or gives up.

```json
{
  "type": "iblt_cells",
  "v": 0,
  "docId": "my-doc",
  "filterId": "f1",
  "cells": [
    { "count": 1, "keySum": "base64...", "valueSum": "base64..." },
    { "count": 2, "keySum": "base64...", "valueSum": "base64..." },
    ...
  ],
  "batchIndex": 0,
  "done": false
}
```

Fields:
- `filterId`: Which filter this IBLT is for.
- `cells`: Array of IBLT cells.
- `batchIndex`: Sequence number for ordering batches.
- `done`: If true, sender has sent all cells they intend to send.

### 4) `IBLTStatus`
Receiver reports decode status after processing IBLT cells.

```json
{
  "type": "iblt_status",
  "v": 0,
  "docId": "my-doc",
  "filterId": "f1",
  "status": "decoded",
  "missingOps": [
    { "replica": "A", "counter": 5 },
    { "replica": "A", "counter": 8 },
    { "replica": "B", "counter": 3 }
  ]
}
```

```json
{
  "type": "iblt_status",
  "v": 0,
  "docId": "my-doc",
  "filterId": "f1",
  "status": "need_more",
  "cellsReceived": 50
}
```

```json
{
  "type": "iblt_status",
  "v": 0,
  "docId": "my-doc",
  "filterId": "f1",
  "status": "failed",
  "reason": "max_cells_exceeded"
}
```

Fields:
- `status`: One of `"decoded"`, `"need_more"`, `"failed"`.
- `missingOps`: When decoded, the opIds that the sender is missing (receiver will send these).

### 5) `OpsBatch`
Sends operations to the peer.

```json
{
  "type": "ops_batch",
  "v": 0,
  "docId": "my-doc",
  "filterId": "f1",
  "ops": [ /* operations */ ],
  "done": false
}
```

Fields:
- `filterId`: Which filter these ops relate to (for tracking/prioritization).
- `ops`: Array of operations.
- `done`: If true, all missing ops for this filter have been sent.

### 6) `Subscribe`
Establishes ongoing subscription for a filter. Server pushes matching ops as they arrive.

```json
{
  "type": "subscribe",
  "v": 0,
  "docId": "my-doc",
  "subscriptionId": "sub-001",
  "filter": { "type": "subtree", "root": "proj-A", "includeAncestors": true }
}
```

### 7) `SubscribeAck`
Acknowledges subscription.

```json
{
  "type": "subscribe_ack",
  "v": 0,
  "docId": "my-doc",
  "subscriptionId": "sub-001",
  "currentLamport": 50
}
```

### 8) `Unsubscribe`
Cancels subscription.

```json
{
  "type": "unsubscribe",
  "v": 0,
  "docId": "my-doc",
  "subscriptionId": "sub-001"
}
```

### 9) `Error`
Signals failures.

```json
{
  "type": "error",
  "v": 0,
  "docId": "my-doc",
  "code": "filter_not_supported",
  "message": "predicate filters require content index",
  "filterId": "f3"
}
```

## Catch-up Algorithm

### Single Filter Sync

```
A (initiator) wants to sync filter F with B (responder):

1. A → B: Hello(filters: [{id: "f1", filter: F}], maxLamport: 42)

2. B → A: HelloAck(acceptedFilters: ["f1"], maxLamport: 50)
   - A observes B's maxLamport

3. A builds IBLT of opIds matching F
   A → B: IBLTCells(filterId: "f1", cells: [...], batchIndex: 0)

4. B receives cells, subtracts own matching opIds, attempts decode
   - If decoded: B → A: IBLTStatus(status: "decoded", missingOps: [...])
   - If not decoded: B → A: IBLTStatus(status: "need_more")
     → A sends more cells, repeat step 4

5. B → A: OpsBatch(filterId: "f1", ops: [ops A is missing], done: true)

6. (Bidirectional) Repeat steps 3-5 with roles reversed if needed
```

### Multiple Filter Sync (Parallel)

```
A wants to sync filters F1, F2, F3 with B:

1. A → B: Hello(filters: [
     {id: "f1", filter: F1},
     {id: "f2", filter: F2},
     {id: "f3", filter: F3}
   ])

2. B → A: HelloAck(acceptedFilters: ["f1", "f2"], rejectedFilters: [{id: "f3", ...}])

3. A builds IBLTs for F1 and F2 (can be parallel)
   A → B: IBLTCells(filterId: "f1", cells: [...])
   A → B: IBLTCells(filterId: "f2", cells: [...])

4. B processes each IBLT independently
   B → A: IBLTStatus(filterId: "f1", status: "decoded", missingOps: [...])
   B → A: IBLTStatus(filterId: "f2", status: "need_more")
   A → B: IBLTCells(filterId: "f2", cells: [...], batchIndex: 1)
   B → A: IBLTStatus(filterId: "f2", status: "decoded", missingOps: [...])

5. B sends ops for each filter
   B → A: OpsBatch(filterId: "f1", ops: [...], done: true)
   B → A: OpsBatch(filterId: "f2", ops: [...], done: true)
```

### Full Sync (All Ops)

Full sync is just filtered sync with `filter: null`:

```
A → B: Hello(filters: [{id: "all", filter: null}])
// ... same IBLT reconciliation flow ...
```

## Worked Example

### Scenario: Syncing Two Subtrees

Tree structure:
```
root
├── projects/
│   ├── proj-A/    ← A wants this
│   │   ├── task-1
│   │   └── task-2
│   └── proj-B/    ← A also wants this
│       └── task-3
└── settings/      ← A doesn't want this
```

Peer A has:
- proj-A ops: `{A#2, A#5}` (2 ops)
- proj-B ops: `{A#3}` (1 op)

Peer B has:
- proj-A ops: `{A#2, A#5, A#8, B#1}` (4 ops)
- proj-B ops: `{A#3, A#6, B#2}` (3 ops)

Sync session:
```
A → B: Hello(filters: [
  {id: "pa", filter: {type: "subtree", root: "proj-A"}},
  {id: "pb", filter: {type: "subtree", root: "proj-B"}}
])

B → A: HelloAck(acceptedFilters: ["pa", "pb"])

// IBLT for proj-A
A → B: IBLTCells(filterId: "pa", cells: [IBLT of {A#2, A#5}])
B: subtracts {A#2, A#5, A#8, B#1}, decodes difference: {A#8, B#1}
B → A: IBLTStatus(filterId: "pa", status: "decoded", missingOps: [{A,8}, {B,1}])

// IBLT for proj-B  
A → B: IBLTCells(filterId: "pb", cells: [IBLT of {A#3}])
B: subtracts {A#3, A#6, B#2}, decodes difference: {A#6, B#2}
B → A: IBLTStatus(filterId: "pb", status: "decoded", missingOps: [{A,6}, {B,2}])

// Send missing ops
B → A: OpsBatch(filterId: "pa", ops: [A#8, B#1], done: true)
B → A: OpsBatch(filterId: "pb", ops: [A#6, B#2], done: true)
```

After sync:
- A has proj-A: `{A#2, A#5, A#8, B#1}` ✓
- A has proj-B: `{A#3, A#6, B#2}` ✓
- A still doesn't have settings/ ops (not requested)

### Content-Based Filter Example

A wants all ops where content contains "urgent":

```
A → B: Hello(filters: [
  {id: "urgent", filter: {type: "predicate", field: "content", op: "contains", value: "urgent"}}
])

// B evaluates predicate, builds set of matching opIds
// IBLT reconciliation proceeds as normal
```

## Implementation Notes

### IBLT Parameters

Recommended IBLT parameters:

| Expected Difference | Cells per Batch | Max Batches |
|---------------------|-----------------|-------------|
| < 100 | 150 | 3 |
| 100-1000 | 1500 | 5 |
| 1000-10000 | 15000 | 10 |
| > 10000 | Negotiate or fall back | - |

Cell size: ~32 bytes (count: 4, keySum: 12, valueSum: 16)

### OpId Encoding for IBLT

OpIds should be encoded consistently for IBLT:
```
opId = hash(replicaId || counter)  // 12-16 bytes
```

Use a deterministic hash (e.g., SipHash, BLAKE3 truncated).

### Filter Evaluation

Server must be able to evaluate filters efficiently. Recommended indexes:

| Filter Type | Required Index |
|-------------|----------------|
| `subtree` | Parent-child, ancestor paths |
| `nodes` | Op → node mapping |
| `lamport_range` | Lamport index |
| `predicate` | Content index or accept full scan |

### Subscription After Sync

After IBLT reconciliation, client can subscribe for ongoing updates:

```
A → B: Subscribe(subscriptionId: "sub-1", filter: {type: "subtree", root: "proj-A"})
B → A: SubscribeAck(subscriptionId: "sub-1", currentLamport: 50)

// B pushes new matching ops as they arrive
B → A: OpsBatch(filterId: "sub-1", ops: [new ops...])
```

### Error Codes

| Code | Description |
|------|-------------|
| `unsupported_version` | Protocol version not supported |
| `filter_not_supported` | Server cannot evaluate the filter |
| `too_many_filters` | Too many filters in single hello |
| `iblt_decode_failed` | IBLT could not be decoded after max cells |
| `rate_limited` | Too many requests |
| `doc_not_found` | Document ID not recognized |

## Security Considerations

### IBLT Privacy

IBLT cells reveal information about which ops a peer has. In adversarial settings:
- An attacker can potentially probe to learn op membership.
- Mitigation: Require authentication before sync, or use encrypted set reconciliation.

### Filter Abuse

Expensive filters can be used for DoS:
- Implementations SHOULD impose time/resource limits on filter evaluation.
- Implementations MAY require authentication before accepting filtered sync.

### Replay and Deduplication

Ops are idempotent by design, but excessive replays waste bandwidth:
- Track recent ops to detect replay attacks.
- Rate limit peers sending duplicate ops.
