# TreeCRDT Sync Protocol v0 (Draft)

This document specifies a minimal, transport-agnostic synchronization protocol for TreeCRDT operation logs.

This is a protocol specification. It does not prescribe a specific implementation. A reference implementation may be
created separately, but this document (and the canonical `.proto` schema) define interoperability.

The key words **MUST**, **MUST NOT**, **REQUIRED**, **SHOULD**, **SHOULD NOT**, and **MAY** are to be interpreted as
described in RFC 2119.

## Status

- **Draft**: backwards compatibility is not guaranteed until the protocol is declared stable.
- **Versioning**: the envelope field `v` identifies the protocol version; this document defines `v = 0`.
- **Encoding**: the canonical wire schema for v0 is Protobuf v3 (see `docs/sync/v0.proto` and `docs/sync/v0/*.proto`).
- **Open issues**:
  - `children(parent)` filter performance requires boundary-crossing move detection (“previous parent == P”).
  - Live updates are supported, but advanced streaming semantics (backpressure, resumable cursors, etc.) are not
    standardized in v0.

## Goals

- Efficiently exchange missing operations between two peers and converge.
- Work over any transport (WebSocket, libp2p, HTTP, file copy, etc.).
- Support filtered sync for partial replication (e.g. “children of node X”).
- Allow multiple concurrent filter streams in a single session.

## Non-goals (v0)

- Encryption / authentication / signatures / ACLs.
- Snapshot transfer, compression, or state checkpoints.
- Complex subscription semantics (server push backpressure, resumable cursors, etc.).

Note: an optional auth extension is specified in `docs/sync/v0/auth.md`. It is not
required for baseline v0 interoperability.

## Terms and Identifiers

All field names in this document follow the canonical Protobuf schema (snake_case). Language bindings MAY expose
different names (e.g. camelCase); that is non-normative as long as the serialized fields are equivalent.

- `doc_id`: document identifier / namespace. Implementations MUST NOT apply operations from one `doc_id` to another.
- `replica_id`: stable identifier for an author/device/replica. In this repo's v0 implementation, this MUST be the
  Ed25519 public key bytes (32 bytes).
- `counter`: monotonically increasing per `replica_id`.
- `op_id`: the pair `(replica_id, counter)` uniquely identifying an operation.
- `op_ref`: fixed-width identifier used for reconciliation (16 bytes in v0), derived from `(doc_id, op_id)`.
- `lamport`: logical timestamp carried by each operation (see `docs/sync/v0/types.proto`).
- `filter`: selection of which operations participate in reconciliation (see `docs/sync/v0/filters.proto`).
- `filter_id`: sender-chosen identifier that names a reconciliation stream for a specific filter (unique within a session).
- `round`: reconciliation attempt number for a `(filter_id, filter)` stream. v0 implementations SHOULD use `round = 0` only.
- `node_id`: node identifier (16 bytes in v0, see `NodeId` in `docs/sync/v0/types.proto`).
- `ROOT`: reserved `node_id` for the canonical root node (all zero bytes / `u128::0`).
- `TRASH`: reserved `node_id` used for soft-deletes (all `0xFF` bytes / `u128::MAX`). A node is considered
  deleted/tombstoned if its canonical parent is `TRASH`.
- `RIBLT`: rateless IBLT reconciliation algorithm; the protocol streams codewords until the receiver can decode the
  symmetric difference.
- `known_state` (delete metadata): writer-side subtree awareness snapshot used by defensive deletion. `delete` ops MUST
  carry this field. Producers SHOULD call local delete APIs (`treecrdt_local_delete` / `TreeCrdt::local_delete`) so
  `known_state` is computed at creation time, instead of hand-crafting raw delete ops.

## Wire Schema (Canonical)

The canonical wire schema is Protobuf v3, split across:

- `docs/sync/v0.proto` (envelope)
- `docs/sync/v0/types.proto` (IDs and metadata)
- `docs/sync/v0/ops.proto` (operations)
- `docs/sync/v0/filters.proto` (filters)
- `docs/sync/v0/messages.proto` (session + reconciliation messages)

This document defines semantics. The `.proto` files define the canonical fields and types.

### Envelope

All protocol traffic is carried inside the `SyncMessage` envelope (see `docs/sync/v0.proto`):

- `v`: protocol version (`uint32`). Implementations MUST set `v = 0` for this protocol version.
- `doc_id`: document identifier (`string`).
- `payload`: exactly one of the defined payload variants.

Receivers MUST reject or ignore unsupported versions and MUST NOT process payloads under the wrong `doc_id`.

## Protocol Overview

A sync session is initiated by an **initiator** (A) against a **responder** (B) for a single `doc_id`:

1. **Handshake**: A proposes one or more filters via `Hello`. B responds with `HelloAck` accepting or rejecting each filter.
2. **Reconciliation** (per accepted filter): A streams `RibltCodewords` for the filter; B decodes and returns
   `RibltStatus(decoded|failed)`.
3. **Op transfer** (per decoded filter): each side sends missing operations in `OpsBatch` messages.
4. **Live updates (optional)**:
   - **Push**: establish a `Subscribe` stream for a filter and receive incremental `OpsBatch` deltas.
   - **Polling**: periodically repeat the catch-up procedure.

Multiple filter streams MAY be interleaved; they are distinguished by `filter_id`.

## Message Semantics

### `Hello`

Initiates a session and proposes filters.

Semantic requirements:

- The initiator MUST choose a unique `FilterSpec.id` for each proposed filter (unique within the session).
- The responder MUST evaluate each proposed filter and either accept it or reject it in `HelloAck`.
- `capabilities` is reserved for feature negotiation. Unknown capabilities MUST be ignored.
- `max_lamport` is the maximum Lamport timestamp known to the sender and MAY be used as a clock observation. It MUST NOT
  affect reconciliation correctness.

### `HelloAck`

Responds to `Hello`.

Semantic requirements:

- `accepted_filters` contains the `FilterSpec.id` values that the responder agrees to reconcile.
- `rejected_filters` contains rejections with structured `reason: ErrorCode` and a human-readable `message`.
- A responder SHOULD reject unsupported or too-expensive filters using `FILTER_NOT_SUPPORTED`.
- `max_lamport` has the same semantics as in `Hello`.

### `RibltCodewords`

Streams reconciliation codewords for a specific `(filter_id, round)`.

Semantic requirements:

- For a given `(filter_id, round)`, the initiator MUST stream codewords in order.
- `start_index` MUST equal the receiver’s next expected codeword index for that `(filter_id, round)`.
- If `start_index` does not match the expected index, the receiver SHOULD terminate the stream with
  `RibltStatus.failed(reason = OUT_OF_ORDER)`.

### `RibltStatus`

Reports reconciliation result for a specific `(filter_id, round)`:

- `decoded` indicates successful decoding of the symmetric difference and includes:
  - `sender_missing`: `op_ref`s present only on the receiver (meaning the sender is missing them)
  - `receiver_missing`: `op_ref`s present only on the sender (meaning the receiver is missing them)
  - `codewords_received`: number of codewords consumed (for observability)
- `failed` indicates terminal failure of this stream and includes:
  - `reason: RibltFailureReason`
  - `message`: optional details (human-readable)

### `OpsBatch`

Transfers operations for a stream identified by `filter_id`.

Semantic requirements:

- `ops` MUST contain valid `Operation` messages (see `docs/sync/v0/ops.proto`).
- Receivers MUST deduplicate operations by `op_id` and treat duplicates as no-ops.
- `done = true` indicates that the sender has finished sending the current batch stream for that `filter_id`.
  - For reconciliation, this typically means “no more ops for this `(filter_id, round)` exchange”.
  - For subscriptions, it indicates the end of the current delta burst; the subscription remains active.

### `Subscribe`, `SubscribeAck`, `Unsubscribe` (Push Subscriptions)

`Subscribe` establishes a live update stream for a single filter.

Semantic requirements:

- The initiator MUST choose a `subscription_id` unique within the session and send `Subscribe(subscription_id, filter)`.
- The responder MUST reply with `SubscribeAck(subscription_id, current_lamport)` to confirm the subscription.
- After `SubscribeAck`, the responder MAY send incremental deltas as `OpsBatch` messages:
  - `OpsBatch.filter_id` MUST be set to the `subscription_id` (so the receiver can route/attribute deltas).
  - `OpsBatch.done` indicates the end of the current delta burst (it MUST NOT be interpreted as “unsubscribe”).
- `Unsubscribe(subscription_id)` terminates the subscription.

Interoperability note: v0 does not define resumable cursors or exactly-once delivery for subscriptions. Implementations
SHOULD run an initial catch-up (e.g. the same procedure used for reconciliation) and/or periodically re-run catch-up to
avoid missing updates due to transient failures.

### `SyncError`

Represents an explicit, fatal on-wire error.

Semantic requirements:

- `code` MUST be an `ErrorCode` enum value.
- `filter_id` and `subscription_id` are optional context fields; implementations MAY omit them when not applicable.
- Implementations MAY choose not to send `SyncError` and instead fail locally. If sent, it SHOULD be treated as terminal
  for the referenced context.

## Filters

Filters define which operations participate in reconciliation for a given stream.

### `Filter.all`

`all` selects the full operation log for the document.

### `Filter.children(parent)`

`children(parent)` selects the operations relevant to the *direct children* of `parent` in the canonical tree state.

Correctness requirement: boundary-crossing moves MUST be included.

For a fixed parent `P`, an operation is considered relevant to `children(P)` if it can change membership or ordering of
`P`’s direct children in canonical state, including:

1. `InsertOp(parent = P, ...)` matches.
2. `MoveOp(new_parent = P, ...)` matches (node enters `P` or is reordered within `P`).
3. `MoveOp(new_parent != P, ...)` matches if the node’s **previous** canonical parent (before applying the op) was `P`
   (node leaves `P`).
4. `DeleteOp(node = X)` and `TombstoneOp(node = X)` MUST be treated as “move to `TRASH`” for canonical parent tracking;
   they match `children(P)` if `X`’s previous canonical parent was `P`.
5. `PayloadOp(node = X, ...)` MUST be included if `X`’s current canonical parent (at the time the payload op is applied)
   is `P` (applies to both payload sets and clears).
6. To support late joiners, implementations SHOULD ensure that a peer subscribing to `children(P)` can reconstruct the
   current payload for each visible child without requiring `all` sync. One interoperable approach is:
   - Track the latest payload op for each node (by op ordering).
   - When a node enters `P` via insert or move, also include that latest payload op in `children(P)` even if it was
     originally applied while the node had a different parent.

Implementations that cannot evaluate “previous canonical parent == P” efficiently SHOULD reject the filter with
`FILTER_NOT_SUPPORTED`.

## Reconciliation (RIBLT Codewords)

The protocol reconciles per-filter sets of `op_ref` using **RIBLT**: a rateless IBLT algorithm that streams “codewords”
until the receiver can decode the symmetric difference.

Why RIBLT: filtered/partial sync makes knowledge sparse (holes), so “contiguous” version vectors are insufficient for
efficient reconciliation. RIBLT correctly reconciles sparse sets (modulo hash collisions) without transmitting the full
set.

### What Is Reconciled

For each `filter_id`, each peer defines the set:

`S(filter) = { op_ref }`

Reconciliation recovers the symmetric difference `S_sender Δ S_receiver`.

### `op_ref` Derivation (16 bytes)

Interop requires all peers to derive identical `op_ref` values for the same `(doc_id, op_id)`.

Canonical v0 derivation:

```
docIdBytes = utf8(doc_id)
opIdBytes  = u32_be(len(replica_id)) || replica_id || u64_be(counter)
op_ref     = blake3("treecrdt/opref/v0" || docIdBytes || opIdBytes)[0..16]
```

Notes:

- `utf8()` is UTF-8 encoding of the `doc_id` string.
- `u32_be()` and `u64_be()` are big-endian integer encodings.
- `replica_id` is the 32-byte Ed25519 public key carried in `OperationId.replica`.

### Codeword Format

Each codeword is the triple `(count, key_sum, value_sum)` (see `RibltCodeword` in `docs/sync/v0/messages.proto`):

- `count`: signed count
- `key_sum`: XOR of 64-bit symbol hashes (MUST be 8 bytes)
- `value_sum`: XOR of 16-byte `op_ref` values (MUST be 16 bytes)

### RIBLT Symbol Hash

Implementations MUST use the same non-linear symbol hash function when generating and decoding codewords.

Define:

```
hi = u64_be(opRef16[0..8])
lo = u64_be(opRef16[8..16])

splitmix64(z):
  z = z + 0x9e3779b97f4a7c15
  z = (z xor (z >> 30)) * 0xbf58476d1ce4e5b9
  z = (z xor (z >> 27)) * 0x94d049bb133111eb
  z = z xor (z >> 31)

hash(opRef16) = splitmix64(hi xor splitmix64(lo xor 0x9e3779b97f4a7c15))
```

The hash MUST be non-linear with respect to `op_ref` bytes; linear projections can degenerate the checksum and break
decoding.

### RIBLT v0 Algorithm

v0 standardizes on the RIBLT algorithm as implemented by `Intersubjective/riblt-rust` (pinned in this repo to
`rev = 23cd9ce6467743bee8c1c734630e461dbed310e5`). Independent implementations MUST match the same
codeword-generation + decoding behavior (in addition to `op_ref` derivation and symbol hashing) to interoperate.

### Streaming and Completion

For a given `(filter_id, round)`:

1. The receiver initializes a decoder with its local set `S_receiver(filter)` (by adding local `op_ref` values).
2. The initiator streams codewords starting from `start_index = 0`, increasing contiguously.
3. The receiver feeds codewords into the decoder until either:
   - it decodes the symmetric difference and sends `RibltStatus(decoded)`, or
   - it fails and sends `RibltStatus(failed)`.

After `RibltStatus(decoded)`:

- The receiver SHOULD send `OpsBatch(filter_id, ops=sender_missing_ops, done=true)` containing operations corresponding
  to `sender_missing` (i.e. ops the sender is missing).
- The sender SHOULD send `OpsBatch(filter_id, ops=receiver_missing_ops, done=true)` containing operations corresponding
  to `receiver_missing` (i.e. ops the receiver is missing).

Ops MAY be split across multiple `OpsBatch` messages before the final `done=true`.

### Failure and Limits

Implementations MUST bound resource usage. Suggested per `(filter_id, round)` limits:

- `max_codewords` (e.g. 50_000) — maximum codewords the receiver will accept before failing.
- `max_ops_in_batch` (e.g. 10_000) — maximum operations per `OpsBatch` (split into multiple batches if needed).

When failing a reconciliation stream, the receiver SHOULD send `RibltStatus.failed` with:

- `reason = OUT_OF_ORDER` if `start_index` is not contiguous,
- `reason = MAX_CODEWORDS_EXCEEDED` if `max_codewords` is hit before decode,
- `reason = DECODE_FAILED` for decoder errors (optionally include a detail string in `message`).

## Error Codes

Structured failures are represented by enums in `docs/sync/v0/messages.proto`:

- `ErrorCode` (used in `RejectedFilter.reason` and `SyncError.code`)
- `RibltFailureReason` (used in `RibltStatus.failed.reason`)

Implementations SHOULD use the most specific code available and MAY include a human-readable `message`.

## Live Updates (Push or Polling)

Typical patterns:

- **Catch-up then subscribe**: run reconciliation once for a filter, then keep up with incremental `OpsBatch` deltas via
  `Subscribe`/`Unsubscribe`.
- **Periodic catch-up**: for transports/backends that don’t implement push, periodically repeat reconciliation for the
  same filters.

## Security Considerations (Non-exhaustive)

- **Reconciliation privacy**: codewords leak information about set membership. Authentication and/or encryption may be
  required in adversarial settings.
- **Filter abuse**: expensive filters can be used for DoS. Implementations SHOULD impose time and resource limits and
  SHOULD reject unsupported filters.
- **Replay/dedup**: operations are idempotent but replay wastes bandwidth. Implementations SHOULD deduplicate
  aggressively and MAY rate-limit peers.

## Implementation Notes (Non-normative, This Repo)

- The TypeScript reference implementation lives in `packages/treecrdt-sync`.
- Protobuf bindings generated with `protoc-gen-es` use `camelCase` in JS/TS, represent `uint64` as `bigint`, and model
  protobuf `oneof` as `{ case, value }`.
