# Sync Protocol v0 (Draft)

This document describes a minimal, transport-agnostic synchronization protocol for TreeCRDT operation logs.

## Status / Open Issues

This is a draft. The largest areas still being nailed down:

- **Children filter performance**: `children(parent)` correctness requires boundary-crossing moves (and deletes/tombstones treated as moves to `TRASH`) and thus evaluating against canonical tree state; current reference implementations do this via log replay, but efficient indexing is still evolving.
- **Live updates semantics**: v0 includes an optional push-based subscription mechanism (`Subscribe`/`Unsubscribe`) but intentionally does not define advanced streaming semantics (backpressure, resumable cursors, etc.).

## Implementation Status (This Repo)

The reference implementation lives in:
- `packages/treecrdt-sync` (TypeScript protocol + in-memory transports)
- `packages/treecrdt-riblt-wasm` (Rust/WASM wrapper over `Intersubjective/riblt-rust`)
- backends that can enumerate `opRef`s and map `opRef → op` (e.g. `treecrdt_oprefs_*` in the SQLite extension)

Notable implementation details (as of this commit):
- **Wire encoding**: protobuf binary (`docs/sync/v0*.proto`) generated with `protoc-gen-es`.
- **In-memory shape (TypeScript)**: matches generated `protoc-gen-es` output — `camelCase` field names, `oneof` fields as `{ case, value }`, `uint64` fields as `bigint`, and protocol enums (`ErrorCode`, `RibltFailureReason`) used directly.
- **Sessions**: `SyncPeer.syncOnce()` runs a single filter at a time, though the protocol supports multiple concurrent filter streams in one `Hello`.
- **Live sync ("subscriptions")**: implemented via dedicated `Subscribe`/`Unsubscribe` wire messages that push incremental `OpsBatch` deltas; `subscribePolling()` remains as a fallback strategy.

## Goals
- Allow two peers who have been offline to efficiently exchange missing operations and converge.
- Work over any transport (libp2p, WebSocket, HTTP, etc).
- Be language/runtime neutral (TypeScript today; Rust later).
- Support filtered sync (query-based sync) for partial synchronization.
- Support multiple concurrent filter queries in a single sync session.

## Non-goals (v0)
- Encryption / E2EE / group key management.
- ACL rules, signature verification, or identity management beyond stable `replicaId`s.
- Snapshots, compression, or advanced anti-entropy.

## Background

TreeCRDT operations are uniquely identified by `(replicaId, counter)` (a per-replica monotonic counter).

Traditional sync uses **version vectors**: for each replica, track the maximum counter seen.
However, version vectors assume **contiguous knowledge** — if you have counter N, you have 1..N.

**Filtered sync breaks this assumption.** When syncing only the immediate children of a particular node,
knowledge becomes **sparse** (e.g., you have R#2, R#5, R#8 but not R#1, R#3, R#4...).

This protocol uses **Rateless IBLT codewords (RIBLT)** for set reconciliation,
which works correctly for both contiguous and sparse knowledge without false positives (modulo hash collisions).

## Terms
- `docId`: document identifier / namespace used to avoid mixing ops from different documents.
- `replicaId`: stable identifier for an author/device/replica. Treated as opaque bytes.
- `counter`: monotonically increasing per `replicaId`.
- `opId`: `(replicaId, counter)` — unique operation identifier.
- `opRef`: fixed-width identifier used for reconciliation (16 bytes in v0).
- `lamport`: logical timestamp carried by each op for ordering and clock observation.
- `filter`: selection of which operations to sync (`Filter.all` = all ops).
- `nodeId`: unique identifier for a node in the tree.
- `ROOT`: reserved `nodeId` for the canonical root node (all zero bytes / `u128::0`).
- `TRASH`: reserved `nodeId` used for soft-deletes (all `0xFF` bytes / `u128::MAX`). A node is considered tombstoned/deleted if its canonical parent is `TRASH`. In this repo’s op model, deletes/tombstones are explicit op kinds but are treated as “move to `TRASH`” for canonical parent tracking and `children(parent)` relevance.
- `RIBLT`: rateless IBLT reconciliation algorithm that streams *codewords* until the receiver can decode the symmetric difference.

## Protocol Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        Sync Session                              │
├─────────────────────────────────────────────────────────────────┤
│  1. Hello: Exchange capabilities, clock, propose filters         │
│                                                                  │
│  2. Reconciliation (per filter, can run in parallel):           │
│     A → B: Stream RIBLT codewords for ops matching filter        │
│     B: Subtract own matching ops, attempt decode                 │
│     B → A: "decoded" or "failed"                                 │
│     (continue until decoded or limit reached)                    │
│                                                                  │
│  3. Op Transfer:                                                 │
│     B → A: Ops that A is missing (from decode)                  │
│     A → B: Ops that B is missing (bidirectional)                │
│                                                                  │
│  4. (Optional) Live updates: repeat catch-up periodically        │
└─────────────────────────────────────────────────────────────────┘
```

## Filters (Query-Based Sync)

A `filter` defines which operations are relevant to a sync session.
Canonical schema: `docs/sync/v0/filters.proto` (`Filter` oneof).

### Supported Filter Kinds (v0)

| Kind | Description | Responder Support Required |
|------|-------------|---------------------------|
| `all` | All ops (full sync) | Ability to enumerate all ops (may be large) |
| `children` | Ops required to maintain the view of the *direct* children of a parent node | Materialized parent/children index; ability to detect moves out of the parent (including moves to/from `TRASH`) |

Servers MAY reject filters they cannot efficiently evaluate with error code `FILTER_NOT_SUPPORTED`.

### Operation Relevance

An operation **matches** a filter based on the filter kind.

Important: for `children`, “matches” cannot always be decided by looking at the op fields alone.
Moves that take a node *out of* the parent’s child list must be sent to keep the view correct, but `MoveOp` does not
include the old parent. Implementations that support `children` therefore need access to a canonical/materialized tree
state (or an equivalent index) to evaluate “was this node a child of P before this move?”.

Let `P = ChildrenFilter.parent`. An op matches `children(P)` if it changes membership or ordering of `P`’s direct child
list in the canonical state:
1. `InsertOp(parent = P, ...)` matches.
2. `MoveOp(new_parent = P, ...)` matches (node enters `P` or is reordered within `P`).
3. `MoveOp(new_parent != P, ...)` matches if the node’s **previous** parent (before applying the op) was `P`
   (node leaves `P`, including delete/tombstone treated as “move to `TRASH`” for view relevance).

Responders that cannot evaluate “previous parent == P” efficiently SHOULD reject the filter with `FILTER_NOT_SUPPORTED`.

Example (why boundary moves matter):

- Filter: `children(parent: "P")`
- Operation: `move(node: "X", new_parent: "B")` (or `new_parent: "TRASH"` for a delete)
- If (in the canonical state) `X` was previously under `P`, then this move MUST be included so the subscriber can remove `X` from the `P` children view.

To sync deeper than one level, clients can issue additional syncs for selected nodes using `children(parent = child_id)`
to progressively load the tree.

## Reconciliation (RIBLT Codewords)

This protocol reconciles per-filter sets of `opRef` using **RIBLT**: a *rateless* IBLT algorithm that streams
decodable “codewords” until the receiver can recover the symmetric difference.

Why this design (vs fixed-size IBLTs + retry rounds):
- No need to guess `cells_total` up-front.
- No “retry with bigger table” rounds; the sender just keeps streaming until decoded.
- Natural fit for sparse knowledge (partial sync) where version-vectors don’t apply.

### What Is Reconciled

For each `filterId`, each peer has a set of items `S(filter) = { opRef }` (where `opRef` is 16 bytes).
Reconciliation recovers the symmetric difference `S_sender Δ S_receiver`.

### Codeword Format

Each codeword is the triple `(count, keySum, valueSum)` (see `RibltCodeword` in `docs/sync/v0/messages.proto`):
- `count`: signed count
- `keySum`: XOR of 64-bit symbol hashes (encoded as 8 big-endian bytes)
- `valueSum`: XOR of 16-byte `opRef` values

Define the symbol hash:

```
hi = u64_be(opRef16[0..8])
lo = u64_be(opRef16[8..16])

splitmix64(z):
  z = z + 0x9e3779b97f4a7c15
  z = (z xor (z >> 30)) * 0xbf58476d1ce4e5b9
  z = (z xor (z >> 27)) * 0x94d049bb133111eb
  z = z xor (z >> 31)

hash(opRef16) = splitmix64(hi xor splitmix64(lo xor 0x9e3779b97f4a7c15))
```

Notes:
- The RIBLT symbol hash MUST be **non-linear** w.r.t. symbol bytes; a linear projection like `u64_be(opRef16[0..8])` can degenerate the checksum and break decoding.
- This exact hash is used by the repo’s `treecrdt-riblt-wasm` wrapper and is required for interop with the current reference implementation.

### Decoding Result

Once decoded, the receiver obtains:
- `receiverMissing`: items present only on the sender (the receiver is missing these)
- `senderMissing`: items present only on the receiver (the sender is missing these)

This is enough for *bidirectional* catch-up with a single codeword stream:
- Responder sends `OpsBatch(senderMissing)` to the initiator.
- Initiator sends `OpsBatch(receiverMissing)` to the responder.

### Streaming / Flow Control

The initiator streams codewords in `RibltCodewords` messages:
- `startIndex` + `codewords[]` MUST form a contiguous sequence for a given `(filterId, round)`.
- The receiver MUST process codewords in order; if it observes a gap or reordering, it SHOULD fail the stream.
- The receiver MAY attempt decode after every codeword or after each batch.

Once the receiver decodes, it sends `RibltStatus(decoded)` and the initiator stops streaming codewords for that stream.

### RIBLT v0 Algorithm

This spec standardizes on the RIBLT algorithm as implemented by `Intersubjective/riblt-rust`
(pinned in this repo to `rev = 23cd9ce6467743bee8c1c734630e461dbed310e5`).
Independent implementations MUST match the same codeword-generation + decoding behavior (in addition to the `opRef`
derivation and `hash(opRef)` definition above) to interoperate.

### Limits / Failure

Implementations MUST bound resource usage (DoS safety). Suggested limits per `(filterId, round)`:
- `maxCodewords` (e.g. 50_000)
- `maxOpsInBatch` (e.g. 10_000)

If the receiver cannot decode within limits, it sends `RibltStatus(failed)` and aborts that filter stream.

### `opRef` (Reconciliation Symbol)

Reconciliation requires fixed-width items, so v0 uses `opRef` (`OpRef.bytes`, 16 bytes) derived from `opId`.
This MUST be standardized for interop.

Canonical v0 proposal:

```
docIdBytes = utf8(docId)
opIdBytes  = u32_be(len(replicaId)) || replicaId || u64_be(counter)
opRef      = blake3("treecrdt/opref/v0" || docIdBytes || opIdBytes)[0..16]
```

Responders must be able to map `opRef → opId → Operation` to answer `OpsBatch` requests.

### Multiple Filters (Parallel Reconciliation)

A sync session can reconcile multiple filters simultaneously by including multiple `FilterSpec` entries in `Hello.filters`.

Each filter gets its own reconciliation stream, identified by `filterId`. Benefits:
- Filters with different set sizes can be streamed/decoded independently
- Receiver can prioritize certain filters
- Partial failures don't block everything
- Better parallelization

Filters MAY overlap. The same operation MAY be transferred multiple times under different `filterId`s.
Receivers MUST deduplicate by `opId` and treat `filterId` as a progress/accounting hint only.

## Encoding

This spec defines message *fields* and *semantics*. The wire encoding is transport-specific.

- Examples in this doc use JSON-like pseudocode; unless noted, field names follow the repo’s in-memory JS/TS shape (camelCase). The `.proto` files remain the canonical wire schema (snake_case).
- Real implementations SHOULD use a canonical binary encoding (CBOR / protobuf) so that:
  - message sizes are smaller, and
  - it is easy to define canonical "bytes-to-sign" later for authenticated sync.

This repo includes a canonical Protobuf schema for v0 split across multiple files:
- `docs/sync/v0.proto` (envelope)
- `docs/sync/v0/types.proto`
- `docs/sync/v0/ops.proto`
- `docs/sync/v0/filters.proto`
- `docs/sync/v0/messages.proto`

Notes:
- In protobuf, `type` is represented by which `SyncMessage.payload` variant is set.
- Full sync is represented by `Filter.all`.
- Node IDs are encoded as 16-byte big-endian values (`NodeId.bytes`).
- Field naming: proto uses `snake_case` (e.g. `doc_id`), while generated JS/TS uses `camelCase` (e.g. `docId`). This repo’s in-memory protocol types follow the generated JS/TS names.
- The TypeScript reference implementation serializes protobuf on the wire, and uses structured JS objects in-memory.

## Messages

Wire schema:
- Envelope: `SyncMessage` in `docs/sync/v0.proto`
- Payload messages: `docs/sync/v0/messages.proto`
- Operations: `docs/sync/v0/ops.proto`
- Filters: `docs/sync/v0/filters.proto`

All protocol traffic is carried inside an envelope (`SyncMessage`) with `{ v, doc_id, payload(oneof) }` semantics.

Implementation note (TypeScript): in-memory messages match generated `protoc-gen-es` output:
`{ v: 0, docId, payload: { case: "hello" | "helloAck" | ..., value: ... } }`.

This section defines semantics (not field lists). Use the `.proto` files for canonical fields.

### `Hello`
- Initiates a sync session, proposes filters, and shares clock state (`maxLamport`, a `uint64` / `bigint` in JS/TS).
- Each `FilterSpec.id` creates an independent reconciliation stream.

### `HelloAck`
- Accepts/rejects filters and shares responder clock state (`maxLamport`, a `uint64` / `bigint` in JS/TS).
- Reject filters that cannot be evaluated efficiently.

### `RibltCodewords`
- Streams a contiguous sequence of reconciliation codewords for `(filterId, round)` using `startIndex` + `codewords[]`.
- There is no fixed “table size”; the sender streams until the receiver reports `decoded` or aborts with `failed`.
- `startIndex` is a `uint64` codeword index; JS/TS bindings represent it as `bigint`.

### `RibltStatus`
- Reports decode result for `(filterId, round)`:
  - `decoded`: includes `senderMissing` and `receiverMissing` opRef sets (the symmetric difference), and may include `codewordsReceived` (stats).
  - `failed`: terminal failure for this filter stream. `reason` is a `RibltFailureReason` enum and `message` may contain details.

### `OpsBatch`
- Transfers operations. Receivers MUST deduplicate by `opId`.

### Live Sync ("Subscription")
- `Subscribe` establishes a live stream for a single filter. The initiator:
  - MUST choose a `subscriptionId` unique within the session
  - SHOULD run an initial catch-up (e.g. `syncOnce(filter)`) to converge historical ops
- The responder MUST reply with `SubscribeAck(subscriptionId, currentLamport)` to confirm the subscription.
- After `SubscribeAck`, the responder MAY send incremental deltas as `OpsBatch` messages:
  - `OpsBatch.filterId` MUST be set to the `subscriptionId` (so the receiver can route/attribute deltas)
  - `OpsBatch.done` indicates the end of the current delta burst (it MUST NOT be interpreted as “unsubscribe”)
- `Unsubscribe(subscriptionId)` terminates the subscription.

### `SyncError` (Reserved)
- Reserved for fatal, explicit on-wire failures.
- The current TypeScript reference implementation does not emit `SyncError` messages; it reports decode failures via `RibltStatus.failed` and surfaces other failures as local exceptions/rejections.

## Catch-up Algorithm

### Single Filter Sync

```
A (initiator) wants to sync filter F with B (responder):

1. A → B: Hello(filters: [{id: "f1", filter: F}], maxLamport: 42)

2. B → A: HelloAck(acceptedFilters: ["f1"], maxLamport: 50)
   - A observes B's maxLamport

3. A starts round 0 and streams RIBLT codewords for F
   A → B: RibltCodewords(filterId: "f1", round: 0, startIndex: 0, codewords: [...])
   ...
   A → B: RibltCodewords(filterId: "f1", round: 0, startIndex: N, codewords: [...])

4. B consumes codewords (with its local set preloaded) and attempts decode
   - If decoded: B → A: RibltStatus(filterId: "f1", round: 0, decoded: { senderMissing: [...], receiverMissing: [...] })
   - If limits exceeded: B → A: RibltStatus(filterId: "f1", round: 0, failed: { reason: RibltFailureReason.MAX_CODEWORDS_EXCEEDED })

5. If decoded:
   - B → A: OpsBatch(filterId: "f1", ops: [ops A is missing], done: true)
   - A → B: OpsBatch(filterId: "f1", ops: [ops B is missing], done: true)
```

### Multiple Filter Sync (Parallel)

```
A wants to sync filters F1, F2, F3 with B:

1. A → B: Hello(filters: [
     {id: "f1", filter: F1},
     {id: "f2", filter: F2},
     {id: "f3", filter: F3}
   ])

2. B → A: HelloAck(acceptedFilters: ["f1", "f2"], rejectedFilters: [{id: "f3", ...}])

3. A streams codewords for F1 and F2 (can be interleaved)
   A → B: RibltCodewords(filterId: "f1", round: 0, startIndex: 0, codewords: [...])
   A → B: RibltCodewords(filterId: "f2", round: 0, startIndex: 0, codewords: [...])
   ...

4. B processes each stream independently and replies when decoded
   B → A: RibltStatus(filterId: "f1", decoded: { senderMissing: [...], receiverMissing: [...] }, round: 0)
   B → A: RibltStatus(filterId: "f2", decoded: { senderMissing: [...], receiverMissing: [...] }, round: 0)

5. B sends ops for each filter, and A sends the ops B is missing
   B → A: OpsBatch(filterId: "f1", ops: [...], done: true)
   A → B: OpsBatch(filterId: "f1", ops: [...], done: true)
   B → A: OpsBatch(filterId: "f2", ops: [...], done: true)
   A → B: OpsBatch(filterId: "f2", ops: [...], done: true)
```

### Full Sync (All Ops)

Full sync is just filtered sync with `Filter.all`:

```
A → B: Hello(filters: [{id: "all", filter: { all: {} }}])
// ... same reconciliation flow ...
```

## Worked Example

### Scenario: Syncing Two Child Lists

Tree structure:
```
root
├── projects/
│   ├── proj-A/    ← A wants this
│   │   ├── task-1
│   │   └── task-2
│   └── proj-B/    ← A also wants this
│       └── task-3
└── settings/      ← A doesn't want this
```

Peer A has:
- children(proj-A) ops: `{A#2, A#5}` (2 ops)
- children(proj-B) ops: `{A#3}` (1 op)

Peer B has:
- children(proj-A) ops: `{A#2, A#5, A#8, B#1}` (4 ops)
- children(proj-B) ops: `{A#3, A#6, B#2}` (3 ops)

Sync session:
```
A → B: Hello(filters: [
  {id: "pa", filter: {children: {parent: "proj-A"}}},
  {id: "pb", filter: {children: {parent: "proj-B"}}}
])

B → A: HelloAck(acceptedFilters: ["pa", "pb"])

// Reconcile proj-A
A → B: RibltCodewords(filterId: "pa", round: 0, startIndex: 0, codewords: [...])
// ... A continues streaming codewords until B decodes ...
B → A: RibltStatus(filterId: "pa", decoded: { senderMissing: [opRef(A#8), opRef(B#1)], receiverMissing: [] }, round: 0)

// Reconcile proj-B
A → B: RibltCodewords(filterId: "pb", round: 0, startIndex: 0, codewords: [...])
// ... A continues streaming codewords until B decodes ...
B → A: RibltStatus(filterId: "pb", decoded: { senderMissing: [opRef(A#6), opRef(B#2)], receiverMissing: [] }, round: 0)

// Send missing ops
B → A: OpsBatch(filterId: "pa", ops: [A#8, B#1], done: true)
B → A: OpsBatch(filterId: "pb", ops: [A#6, B#2], done: true)
```

After sync:
- A has children(proj-A): `{A#2, A#5, A#8, B#1}` ✓
- A has children(proj-B): `{A#3, A#6, B#2}` ✓
- A still doesn't have settings/ ops (not requested)

## Implementation Notes

### RIBLT Streaming Parameters

Suggested defaults (tune empirically):
- `codewordsPerMessage`: 256–2048 (trade latency vs overhead)
- `maxCodewords`: 50_000 per `(filterId, round)` (DoS bound)
- attempt decode every 32–256 codewords (amortize decode work)

Approximate per-codeword payload size: 28 bytes (`count`: 4, `keySum`: 8, `valueSum`: 16), plus encoding overhead.

### OpId / OpRef Encoding

Interop requires both peers compute identical `opRef` for the same `opId`. v0 proposes a canonical BLAKE3-based `opRef`
derivation; see the `opRef` section above.

### Filter Evaluation

Server must be able to evaluate filters efficiently. Recommended indexes:

| Filter Kind | Required Index |
|-------------|----------------|
| `all` | Ability to enumerate the full op log |
| `children` | Materialized parent/children + ability to evaluate “previous parent == P” for moves out of `P` (including moves to/from `TRASH`) via replay or stored pre-parent per op |

To avoid scanning the full op log for `children(parent = P)`, responders SHOULD maintain an inverted index keyed by
`P` that lists all ops that ever affected the membership or ordering of `P`’s direct children:
- On `InsertOp(parent = P, ...)`, index the op under `P`.
- On `MoveOp(node, new_parent = Q, ...)`, look up `old_parent` from the canonical/materialized state *before* applying
  the move, then index the op under `Q` and (if `old_parent` exists) also under `old_parent` (so moves out of `P`,
  including deletes as moves to `TRASH`, are discoverable without replay).

### Live Updates After Sync (Push or Polling)

After reconciliation, a client can keep a view “live” either by:
- **Polling**: periodically running the same catch-up again with the same filter, or
- **Push subscriptions**: using `Subscribe`/`Unsubscribe` to receive incremental `OpsBatch` deltas.

Implementation note: in this repo, `SyncPeer.subscribe(...)` uses `Subscribe` wire messages (push deltas) and runs an
optional initial `syncOnce()` by default. `SyncPeer.subscribePolling(...)` is the legacy polling strategy.

### Error Codes

The `.proto` schema defines enums for structured failures:
- `ErrorCode` (used in `RejectedFilter.reason` and `SyncError.code`)
- `RibltFailureReason` (used in `RibltStatus.failed.reason`)

The current TypeScript implementation uses these enums directly. The following values are recommended/reserved:

| Code | Description |
|------|-------------|
| `ERROR_CODE_UNSPECIFIED` | Default/unknown |
| `UNSUPPORTED_VERSION` | Protocol version not supported |
| `FILTER_NOT_SUPPORTED` | Server cannot evaluate the filter |
| `TOO_MANY_FILTERS` | Too many filters in single hello |
| `RECONCILIATION_DECODE_FAILED` | Reconciliation could not be decoded within limits |
| `RATE_LIMITED` | Too many requests |
| `DOC_NOT_FOUND` | Document ID not recognized |

`RibltFailureReason` values:

| Reason | Description |
|--------|-------------|
| `RIBLT_FAILURE_REASON_UNSPECIFIED` | Default/unknown |
| `MAX_CODEWORDS_EXCEEDED` | Stream did not decode before `maxCodewords` |
| `DECODE_FAILED` | Decoder reported failure (optionally include details in `RibltFailed.message`) |
| `OUT_OF_ORDER` | `startIndex` did not match the receiver’s expected index |

## Security Considerations

### Reconciliation Privacy

Reconciliation codewords reveal information about which ops a peer has. In adversarial settings:
- An attacker can potentially probe to learn op membership.
- Mitigation: Require authentication before sync, or use encrypted set reconciliation.

### Filter Abuse

Expensive filters can be used for DoS:
- Implementations SHOULD impose time/resource limits on filter evaluation (e.g., `all` or `children` on a very large parent).
- Implementations MAY require authentication before accepting filtered sync.

### Replay and Deduplication

Ops are idempotent by design, but excessive replays waste bandwidth:
- Track recent ops to detect replay attacks.
- Rate limit peers sending duplicate ops.
