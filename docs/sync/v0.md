# Sync Protocol v0 (Draft)

This document describes a minimal, transport-agnostic synchronization protocol for TreeCRDT operation logs.

## Status / Open Issues

This is a draft. The largest areas still being nailed down:

- **Children filter correctness**: a correct “children of parent” sync must include boundary-crossing moves (including deletes, which are moves to `TRASH`); that requires evaluating filters against a canonical tree state, not just `new_parent` fields.
- **IBLT interop details**: we need a precise, testable definition of how items are encoded, hashed, streamed, and decoded so independent implementations converge.

## Goals
- Allow two peers who have been offline to efficiently exchange missing operations and converge.
- Work over any transport (libp2p, WebSocket, HTTP, etc).
- Be language/runtime neutral (TypeScript today; Rust later).
- Support filtered sync (query-based sync) for partial synchronization.
- Support multiple concurrent filter queries in a single sync session.

## Non-goals (v0)
- Encryption / E2EE / group key management.
- ACL rules, signature verification, or identity management beyond stable `replicaId`s.
- Snapshots, compression, or advanced anti-entropy.

## Background

TreeCRDT operations are uniquely identified by `(replicaId, counter)` (a per-replica monotonic counter).

Traditional sync uses **version vectors**: for each replica, track the maximum counter seen.
However, version vectors assume **contiguous knowledge** — if you have counter N, you have 1..N.

**Filtered sync breaks this assumption.** When syncing only the immediate children of a particular node,
knowledge becomes **sparse** (e.g., you have R#2, R#5, R#8 but not R#1, R#3, R#4...).

This protocol uses **Rateless IBLT (Invertible Bloom Lookup Tables)** for set reconciliation,
which works correctly for both contiguous and sparse knowledge without false positives (modulo hash collisions).

## Terms
- `docId`: document identifier / namespace used to avoid mixing ops from different documents.
- `replicaId`: stable identifier for an author/device/replica. Treated as opaque bytes.
- `counter`: monotonically increasing per `replicaId`.
- `opId`: `(replicaId, counter)` — unique operation identifier.
- `opRef`: fixed-width identifier used inside IBLTs (a hash of `opId` bytes; see below).
- `lamport`: logical timestamp carried by each op for ordering and clock observation.
- `filter`: selection of which operations to sync (`Filter.all` = all ops).
- `nodeId`: unique identifier for a node in the tree.
- `ROOT`: reserved `nodeId` for the canonical root node (all zero bytes / `u128::0`).
- `TRASH`: reserved `nodeId` used for soft-deletes (all `0xFF` bytes / `u128::MAX`). A node is considered “tombstoned/deleted” if its parent is `TRASH`. Deleting is encoded as `move(node, TRASH, 0)`; restoring is a `move` back out of `TRASH`.
- `IBLT`: Invertible Bloom Lookup Table — data structure for set reconciliation.
- `rateless IBLT`: IBLT variant that streams cells until receiver can decode.

## Protocol Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        Sync Session                              │
├─────────────────────────────────────────────────────────────────┤
│  1. Hello: Exchange capabilities, clock, propose filters         │
│                                                                  │
│  2. IBLT Reconciliation (per filter, can run in parallel):      │
│     A → B: Stream IBLT cells for ops matching filter             │
│     B: Subtract own matching ops, attempt decode                 │
│     B → A: "decoded" or "need-more"                             │
│     (repeat until decoded or limit reached)                      │
│                                                                  │
│  3. Op Transfer:                                                 │
│     B → A: Ops that A is missing (from IBLT decode)             │
│     A → B: Ops that B is missing (bidirectional)                │
│                                                                  │
│  4. (Optional) Subscribe: Ongoing filtered updates               │
└─────────────────────────────────────────────────────────────────┘
```

## Filters (Query-Based Sync)

A `filter` defines which operations are relevant to a sync session.
Canonical schema: `docs/sync/v0/filters.proto` (`Filter` oneof).

### Supported Filter Kinds (v0)

| Kind | Description | Responder Support Required |
|------|-------------|---------------------------|
| `all` | All ops (full sync) | Ability to enumerate all ops (may be large) |
| `children` | Ops required to maintain the view of the *direct* children of a parent node | Materialized parent/children index; ability to detect moves out of the parent (including moves to/from `TRASH`) |

Servers MAY reject filters they cannot efficiently evaluate with error code `FILTER_NOT_SUPPORTED`.

### Operation Relevance

An operation **matches** a filter based on the filter kind.

Important: for `children`, “matches” cannot always be decided by looking at the op fields alone.
Moves that take a node *out of* the parent’s child list must be sent to keep the view correct, but `MoveOp` does not
include the old parent. Implementations that support `children` therefore need access to a canonical/materialized tree
state (or an equivalent index) to evaluate “was this node a child of P before this move?”.

Let `P = ChildrenFilter.parent`. An op matches `children(P)` if it changes membership or ordering of `P`’s direct child
list in the canonical state:
1. `InsertOp(parent = P, ...)` matches.
2. `MoveOp(new_parent = P, ...)` matches (node enters `P` or is reordered within `P`).
3. `MoveOp(new_parent != P, ...)` matches if the node’s **previous** parent (before applying the op) was `P`
   (node leaves `P`, including delete as `move(node, TRASH, 0)`).

Responders that cannot evaluate “previous parent == P” efficiently SHOULD reject the filter with `FILTER_NOT_SUPPORTED`.

Example (why boundary moves matter):

- Filter: `children(parent: "P")`
- Operation: `move(node: "X", new_parent: "B")` (or `new_parent: "TRASH"` for a delete)
- If (in the canonical state) `X` was previously under `P`, then this move MUST be included so the subscriber can remove `X` from the `P` children view.

To sync deeper than one level, clients can issue additional syncs for selected nodes using `children(parent = child_id)`
to progressively load the tree.

## Rateless IBLT Reconciliation

This protocol uses **Rateless IBLT** for set reconciliation. Unlike bloom filters, IBLT provides
**exact reconciliation with no false positives** (modulo hash collisions).

### How IBLT Works

An IBLT is a data structure that can:
1. Insert items (`opRef`s)
2. Be subtracted from another IBLT
3. Decode to extract the symmetric difference

**Rateless** means the sender streams IBLT cells until the receiver can decode — no need to
pre-negotiate sizes or know the difference size upfront.

### v0 Interop Profile: Deterministic IBLT + Retry

“Rateless” is the long-term goal, but independent implementations need a precise, testable baseline.
For v0 interoperability, implementations SHOULD support the following **deterministic IBLT** and
“retry with larger table” behavior:

**IBLT parameters**
- `k` (hash functions): default `3`
- `cells_total` (table size): chosen by sender
- `seed`: 16 random bytes chosen by sender per `(filter_id, round)`

**Cell indices**

For each item `x = opRef` and each `i in [0..k)`, compute:

```
idx(x, i) = u64_le(blake3("treecrdt/iblt/index/v0" || seed || u8(i) || x)[0..8]) % cells_total
```

**Insert / delete item**

Each IBLT cell stores `{count, key_sum, value_sum}` as described above.

- Insert `x`:
  - for each `i`: cell[idx(x,i)].count += 1
  - cell[idx(x,i)].key_sum XOR= H(x)
  - cell[idx(x,i)].value_sum XOR= x
- Delete `x` (used when subtracting the receiver’s set):
  - same as insert, but `count -= 1`

**Decode**

Iteratively peel “pure” cells until no progress:
- A cell is *pure* if `abs(count) == 1` and `H(value_sum) == key_sum`.
- The recovered item is `x = value_sum`.
- If `count == 1`, then `x` is present only on the sender. If `count == -1`, `x` is present only on the receiver.
- Remove `x` from all `k` cells by applying the inverse update (delete if `count==1`, insert if `count==-1`).

If decoding cannot peel all cells to zero, treat the round as decode failure.

**Retry**

- The sender streams the IBLT table cells in one or more `IbltCells` messages for a given `(filter_id, round)`.
- Each `IbltCells` message provides a contiguous slice of the table via `start_index` + `cells[]`.
- The receiver attempts decode after `done: true` (i.e., after all `cells_total` cells have been received).
- On failure, the receiver replies with `IbltStatus(need_more: { suggested_cells_total: ... })`.
- The sender starts a new `round` with a new `seed` and a larger `cells_total`.

### One-Way IBLT Sync

```
A wants to sync with B (A is the initiator):

1. A builds IBLT of matching items (`opRef`s) for the filter
2. A → B: Stream IBLT cells
3. B subtracts own matching items from received IBLT
4. B attempts decode:
   - Success: B can derive both sides’ missing op sets
   - Failure: B → A: "need-more" (retry with a larger `cells_total`)
5. Repeat rounds until decoded (or a limit is reached)
6. B → A: Send missing ops
```

### Bidirectional Sync

IBLT decoding yields the **symmetric difference**, so a single IBLT stream is enough for bidirectional catch-up:
- A sends IBLT → B decodes → B learns both “ops A is missing” and “ops B is missing”
- B sends ops A is missing, and optionally a list (`receiver_missing`) so A can send ops B is missing

Running IBLT in both directions is OPTIONAL and mainly useful for:
- balancing compute between peers, or
- avoiding sending a potentially large `receiver_missing` list.

### Why IBLT Over Bloom Filters

| Aspect | Bloom Filter | Rateless IBLT |
|--------|--------------|---------------|
| False positives | ~1% (might skip needed ops) | **None** (modulo hash collisions) |
| Communication | O(n) — size of known set | O(d) — size of difference |
| Bidirectional | Requires two exchanges | Single structure encodes both directions |
| Small differences | Wasteful | Efficient |
| Large differences | Efficient | Still works, more cells needed |

### IBLT Cell Format

Each IBLT cell is the triple `(count, key_sum, value_sum)` (see `IbltCell` in `docs/sync/v0/messages.proto`):
- `count`: signed count; subtraction can produce negative values
- `key_sum`: XOR of `H(opRef)` for all items in this cell
- `value_sum`: XOR of `opRef` for all items in this cell

Cells are streamed in batches. The receiver MAY attempt decode after each batch; in the v0 interop profile, it
attempts decode after `done: true` (i.e., after the full table has been received).

### `opRef` Encoding (Used Inside IBLTs)

`opId` is variable-sized (replica IDs are opaque bytes), but IBLT XOR sums require fixed-width items. v0 therefore
uses `opRef` as the *IBLT item*:

```
docIdBytes = utf8(docId)
opIdBytes = u32_be(len(replicaId)) || replicaId || u64_be(counter)
opRef = blake3("treecrdt/opref/v0" || docIdBytes || opIdBytes)[0..16]   // 16 bytes
H(x) = blake3("treecrdt/ibltkey/v0" || x)[0..16]                        // 16 bytes
```

Notes:
- Truncating BLAKE3 to 16 bytes makes collisions *practically* negligible; implementations MAY use 32 bytes if desired.
- `opRef` is only for reconciliation and lookup; `OpsBatch` always transmits full operations (including full `{replica,counter}`).

### Multiple Filters (Parallel Reconciliation)

A sync session can reconcile multiple filters simultaneously by including multiple `FilterSpec` entries in `Hello.filters`.

Each filter gets its own IBLT stream, identified by `filter_id`. Benefits:
- Filters with different set sizes get appropriate cell counts
- Receiver can prioritize certain filters
- Partial failures don't block everything
- Better parallelization

Filters MAY overlap. The same operation MAY be transferred multiple times under different `filter_id`s.
Receivers MUST deduplicate by `opId` and treat `filter_id` as a progress/accounting hint only.

## Encoding

This spec defines message *fields* and *semantics*. The wire encoding is transport-specific.

- Examples in this doc use JSON-like pseudocode and proto message/field names for readability.
- Real implementations SHOULD use a canonical binary encoding (CBOR / protobuf) so that:
  - message sizes are smaller, and
  - it is easy to define canonical "bytes-to-sign" later for authenticated sync.

This repo includes a canonical Protobuf schema for v0 split across multiple files:
- `docs/sync/v0.proto` (envelope)
- `docs/sync/v0/types.proto`
- `docs/sync/v0/ops.proto`
- `docs/sync/v0/filters.proto`
- `docs/sync/v0/messages.proto`

Notes:
- In protobuf, `type` is represented by which `SyncMessage.payload` variant is set.
- Full sync is represented by `Filter.all`.
- Node IDs are encoded as 16-byte big-endian values (`NodeId.bytes`).

## Messages

Wire schema:
- Envelope: `SyncMessage` in `docs/sync/v0.proto`
- Payload messages: `docs/sync/v0/messages.proto`
- Operations: `docs/sync/v0/ops.proto`
- Filters: `docs/sync/v0/filters.proto`

All protocol traffic is carried inside `SyncMessage { v, doc_id, payload }`.
The message “type” is the chosen `payload` variant.

This section defines semantics (not field lists). Use the `.proto` files for canonical fields.

### `Hello`
- Initiates a sync session, proposes filters, and shares clock state (`max_lamport`).
- Each `FilterSpec.id` creates an independent reconciliation stream.

### `HelloAck`
- Accepts/rejects filters and shares responder clock state (`max_lamport`).
- Reject filters that cannot be evaluated efficiently.

### `IbltCells`
- Streams a contiguous slice of the IBLT table for `(filter_id, round)` using `start_index` + `cells[]`.
- A round is complete when the sender has delivered all `cells_total` cells and sets `done = true`.

### `IbltStatus`
- Reports decode result for `(filter_id, round)` via a oneof payload:
  - `decoded`: includes `sender_missing` and `receiver_missing` opRef sets.
  - `need_more`: includes `suggested_cells_total` for the next round.
  - `failed`: terminal failure for this filter stream.

### `OpsBatch`
- Transfers operations. Receivers MUST deduplicate by `opId`.
- For subscriptions, `filter_id` MUST equal `subscription_id`.

### `Subscribe` / `SubscribeAck` / `Unsubscribe`
- Establish/cancel ongoing delivery of ops matching a filter after catch-up.

### `SyncError`
- Signals failures. Error codes are defined in `docs/sync/v0/messages.proto`.

## Catch-up Algorithm

### Single Filter Sync

```
A (initiator) wants to sync filter F with B (responder):

1. A → B: Hello(filters: [{id: "f1", filter: F}], max_lamport: 42)

2. B → A: HelloAck(accepted_filters: ["f1"], max_lamport: 50)
   - A observes B's max_lamport

3. A starts round 0 and streams a full IBLT table for F
   A → B: IbltCells(filter_id: "f1", round: 0, iblt: {...}, start_index: 0, cells: [...], batch_index: 0)
   ...
   A → B: IbltCells(filter_id: "f1", round: 0, iblt: {...}, start_index: ..., cells: [...], batch_index: N, done: true)

4. B subtracts own matching items and attempts decode
   - If decoded: B → A: IbltStatus(filter_id: "f1", round: 0, decoded: { sender_missing: [...], receiver_missing: [...] })
   - If decode fails: B → A: IbltStatus(filter_id: "f1", round: 0, need_more: { suggested_cells_total: ... })
     → A retries at `round: 1` with a larger `cells_total`

5. If decoded:
   - B → A: OpsBatch(filter_id: "f1", ops: [ops A is missing], done: true)
   - (Optional) A → B: OpsBatch(filter_id: "f1", ops: [ops B is missing], done: true)

6. (Alternative) If B includes `receiver_missing` in `IbltStatus.decoded`, A can immediately send its missing ops without B building a second IBLT.
```

### Multiple Filter Sync (Parallel)

```
A wants to sync filters F1, F2, F3 with B:

1. A → B: Hello(filters: [
     {id: "f1", filter: F1},
     {id: "f2", filter: F2},
     {id: "f3", filter: F3}
   ])

2. B → A: HelloAck(accepted_filters: ["f1", "f2"], rejected_filters: [{id: "f3", ...}])

3. A builds IBLTs for F1 and F2 (can be parallel)
   A → B: IbltCells(filter_id: "f1", round: 0, iblt: {...}, start_index: 0, cells: [...], done: true)
   A → B: IbltCells(filter_id: "f2", round: 0, iblt: {...}, start_index: 0, cells: [...], done: true)

4. B processes each IBLT independently
   B → A: IbltStatus(filter_id: "f1", decoded: { sender_missing: [...], receiver_missing: [...] }, round: 0)
   B → A: IbltStatus(filter_id: "f2", need_more: { suggested_cells_total: ... }, round: 0)
   A → B: IbltCells(filter_id: "f2", round: 1, iblt: {...}, start_index: 0, cells: [...], done: true)
   B → A: IbltStatus(filter_id: "f2", decoded: { sender_missing: [...], receiver_missing: [...] }, round: 1)

5. B sends ops for each filter
   B → A: OpsBatch(filter_id: "f1", ops: [...], done: true)
   B → A: OpsBatch(filter_id: "f2", ops: [...], done: true)
```

### Full Sync (All Ops)

Full sync is just filtered sync with `Filter.all`:

```
A → B: Hello(filters: [{id: "all", filter: { all: {} }}])
// ... same IBLT reconciliation flow ...
```

## Worked Example

### Scenario: Syncing Two Child Lists

Tree structure:
```
root
├── projects/
│   ├── proj-A/    ← A wants this
│   │   ├── task-1
│   │   └── task-2
│   └── proj-B/    ← A also wants this
│       └── task-3
└── settings/      ← A doesn't want this
```

Peer A has:
- children(proj-A) ops: `{A#2, A#5}` (2 ops)
- children(proj-B) ops: `{A#3}` (1 op)

Peer B has:
- children(proj-A) ops: `{A#2, A#5, A#8, B#1}` (4 ops)
- children(proj-B) ops: `{A#3, A#6, B#2}` (3 ops)

Sync session:
```
A → B: Hello(filters: [
  {id: "pa", filter: {children: {parent: "proj-A"}}},
  {id: "pb", filter: {children: {parent: "proj-B"}}}
])

B → A: HelloAck(accepted_filters: ["pa", "pb"])

// IBLT for proj-A
A → B: IbltCells(filter_id: "pa", round: 0, iblt: {...}, start_index: 0, cells: [IBLT of {A#2, A#5}], done: true)
B: subtracts {A#2, A#5, A#8, B#1}, decodes difference: {A#8, B#1}
B → A: IbltStatus(filter_id: "pa", decoded: { sender_missing: [opRef(A#8), opRef(B#1)], receiver_missing: [] }, round: 0)

// IBLT for proj-B  
A → B: IbltCells(filter_id: "pb", round: 0, iblt: {...}, start_index: 0, cells: [IBLT of {A#3}], done: true)
B: subtracts {A#3, A#6, B#2}, decodes difference: {A#6, B#2}
B → A: IbltStatus(filter_id: "pb", decoded: { sender_missing: [opRef(A#6), opRef(B#2)], receiver_missing: [] }, round: 0)

// Send missing ops
B → A: OpsBatch(filter_id: "pa", ops: [A#8, B#1], done: true)
B → A: OpsBatch(filter_id: "pb", ops: [A#6, B#2], done: true)
```

After sync:
- A has children(proj-A): `{A#2, A#5, A#8, B#1}` ✓
- A has children(proj-B): `{A#3, A#6, B#2}` ✓
- A still doesn't have settings/ ops (not requested)

## Implementation Notes

### IBLT Parameters

Recommended IBLT parameters:

| Expected Difference | Cells per Batch | Max Batches |
|---------------------|-----------------|-------------|
| < 100 | 150 | 3 |
| 100-1000 | 1500 | 5 |
| 1000-10000 | 15000 | 10 |
| > 10000 | Negotiate or fall back | - |

Cell size: ~36 bytes (count: 4, key_sum: 16, value_sum: 16)

### OpId Encoding for IBLT

See `opRef` encoding above. Implementations MUST use a canonical byte encoding for `replicaId` and `counter` when hashing.

### Filter Evaluation

Server must be able to evaluate filters efficiently. Recommended indexes:

| Filter Kind | Required Index |
|-------------|----------------|
| `all` | Ability to enumerate the full op log |
| `children` | Materialized parent/children + ability to evaluate “previous parent == P” for moves out of `P` (including moves to/from `TRASH`) via replay or stored pre-parent per op |

To avoid scanning the full op log for `children(parent = P)`, responders SHOULD maintain an inverted index keyed by
`P` that lists all ops that ever affected the membership or ordering of `P`’s direct children:
- On `InsertOp(parent = P, ...)`, index the op under `P`.
- On `MoveOp(node, new_parent = Q, ...)`, look up `old_parent` from the canonical/materialized state *before* applying
  the move, then index the op under `Q` and (if `old_parent` exists) also under `old_parent` (so moves out of `P`,
  including deletes as moves to `TRASH`, are discoverable without replay).

### Subscription After Sync

After IBLT reconciliation, client can subscribe for ongoing updates:

```
A → B: Subscribe(subscription_id: "sub-1", filter: {children: {parent: "proj-A"}})
B → A: SubscribeAck(subscription_id: "sub-1", current_lamport: 50)

// B pushes new matching ops as they arrive
B → A: OpsBatch(filter_id: "sub-1", ops: [new ops...])
```

### Error Codes

| Code | Description |
|------|-------------|
| `UNSUPPORTED_VERSION` | Protocol version not supported |
| `FILTER_NOT_SUPPORTED` | Server cannot evaluate the filter |
| `TOO_MANY_FILTERS` | Too many filters in single hello |
| `IBLT_DECODE_FAILED` | IBLT could not be decoded after max cells |
| `RATE_LIMITED` | Too many requests |
| `DOC_NOT_FOUND` | Document ID not recognized |

## Security Considerations

### IBLT Privacy

IBLT cells reveal information about which ops a peer has. In adversarial settings:
- An attacker can potentially probe to learn op membership.
- Mitigation: Require authentication before sync, or use encrypted set reconciliation.

### Filter Abuse

Expensive filters can be used for DoS:
- Implementations SHOULD impose time/resource limits on filter evaluation (e.g., `all` or `children` on a very large parent).
- Implementations MAY require authentication before accepting filtered sync.

### Replay and Deduplication

Ops are idempotent by design, but excessive replays waste bandwidth:
- Track recent ops to detect replay attacks.
- Rate limit peers sending duplicate ops.
